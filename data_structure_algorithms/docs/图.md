# 1 图的概念性质和实现

## 1.1 定义
1. 一个图是一个二元组 `G=(V,E)`,其中：
    * V是非空又穷的顶点集合。(空图意义不大)
    * E是顶点的偶对(称为边)的集合，E∈V*V
    * V中的顶点也是图G的顶点，E中的边也是图G的边。
2. 有向图和无向图
    * 有向图的边有方向，是顶点的序对，如`<vi, vj>` 和`<vj, vi>`是两条边。
    * 无向图的边没有方向，是顶点的无序对，如`(vi, vj)` 和`(vj, vi)`是同一条边。
3. 图G中边`<vi, vj>∈E`(无向图`(vi, vj)∈E`)则称顶点`vj`是顶点`vi`的邻接顶点或邻接点（无向图邻接关系是双向的）。也称这条边为顶点`vi`相关联的边，或者`vi`的邻接边。`E`表示顶点间的邻接关系。
    * 不考虑顶点到自身的边，`vi≠vj`。
    * 同一顶点间没有重复的边。（如果重复则是另一列稍不同的数学对象）

## 1.2 概念和性质
1. 完全图：任意两个顶点都有边的图（有向图或无向图）。
    * n个顶点的无向完全图有`n*(n-1)/2`条边。
    * n个顶点的有向完全图有`n*(n-1)`条边。
2. 度：一个顶点的度就是于它邻接的边的条数。
    * 有向图还分出度和入度，有向图的度是入度出度之和。
    * 无论有向图和无向图，顶点数n,边数e,和顶点的度满足下面的关系：
        * `e=1/2∑D(vi)` 其中D(vi)表示顶点vi的度数。
3. 路径：对于无向图G=(V,E)，如果存在顶点序列 `vi0,vi1,vi2...vim`,使得`(vi0, vi1),(vi1,vi2),...,(vim-1,vim)∈E`,则说vi0到vim存在路径。并称`<vi0,vi1,vi2,...,vim>`是从顶点vi0到vim的一条路径。对于有向图，`<vi0, vi1>,<vi1,vi2>,...,<vim-1,vim>∈E`则则说vi0到vim存在路径。
    * 路径长度：该路径上边的条数。
    * 回路(环)：起点和终点相同的路径。
    * 为简单回路：一个环路除起点和终点外其他的顶点均不相同。
    * 简单路径：内部不包含回路的路径。简单回路也是简单路径。也就是说除起点和终点外，其他顶点均不相同。
    * 有根图：有向图G中存在顶点v,从v到G中每个顶点都有路径，则称G为有根图。v是G的一个根。根可能不唯一。
4. 连通：对于无向图G，若vi到vj有路径，则说vi到vj是连通的。对于有向图，连通的定义类似，但是连通可以不是双向的。
    * 连通无向图：若无向图G中任意两个顶点都是连通的，则称G是连通无向图。
    * 强连通有向图：若有向图G中，vi与vj之间是连通的，而且vj与vi也是连通的（有向图中要求顶点间两个方向的路径都存在），则称G为强连通有向图。
    * 最小连通图：连通图，但是去掉任何一条边将不再是连通图。
        * 包含n个顶点的最小联调无向图G恰有n-条边。
    * 包含n个顶点的最小有根图（去掉任一条边将不再是有根图）恰好有n-1条边。
5. 子图：图`G=(V,E)`,如果`V1∈V, E1∈E`则G1是G的子图。G是G自身的子图。
    * 一个图可能不是连通图或强连通图，但是它的子图可以是连通的或强连通的，这种子图称为原图的连通子图或强连通子图。
    * 极大连通子图(连通分量)：G1是无向图G的连通子图，且G1的顶点和边的集合都已经不能扩充（扩充后不连通）。
        * 如果G本身是连通图，它只有一个连通分量就是它本身。* 如果G不连通，则其连通分量多于一个。
    * 有向图G的一个极大强连通子图称为它的一个强连通分量。
6. 带权图：图G中每条边上有被赋予一个权值，则称G为带权图（可以是有向图和无向图）。
    * 网络：带权的连通无向图。


## 1.3 抽象数据类型
* ADT Graph:
    * Graph()       初始化
    * is_empty()    是否为空图
    * vertex_num()  获取图顶点的个数
    * edge_num()    获取图边的条数
    * vertexs()     获取图顶点集合
    * edges()       获取图边的集合
    * add_vertex(vertex)    将新顶点加入图
    * get_edge(v1, v2)  获取顶点v1,v2的边
    * add_edge(v1, v2)  将顶点v1,v2的边加入图
    * out_edges(v)  获取v出发的所有边
    * degree(v)     获取v的度

图中可能有回路，图有可能不连通，注意图的遍历问题。

## 1.4 图的表示和实现

### 邻接矩阵
* 邻接矩阵就是表示图中顶点邻接关系的方阵。n个顶点的有向图G=(V,E),其邻接矩阵是n*n的方阵，每个顶点按顺序对应于矩阵中的一行一列，矩阵元素表示邻接关系。
    * 邻接矩阵0/1表示A(i,j)：
        * 0： 顶点vi到顶点vj无边
        * 1： 顶点vi到顶点vj有边
    * 带权图邻接矩阵表示A(i,j)：
        * w(i,j)： 顶点vi到vj有边，且权是w(i,j)。
        * 0或无穷大：顶点vi到vj无边，无穷大可以是特殊值。

```
G3 = (V,E)
V = (a, b, c)
E = (<a, c>, <b, a>, <b, c>, <c, b>)

                a   b   c
            a   0   0   1         
a(i,j) =    b   1   0   1
            c   0   1   0

如：行a表示顶点a到顶点a,b,c是否有边。
没有考虑自身到自身的边，所以对角线上都是0。
无向图都是对称的，因为邻接关系是对称的。
```    
缺点：邻接矩阵比较稀疏，空间浪费很大，不适合大图。

### 邻接表
* 邻接表就是为图中每个顶点关联一个边表，其中记录这个顶点的左右邻接边。
    * 一般用顺序表表示顶点，每个顶点关联一个其邻接边表的链表。
    * 如果边有权，需要新增字段显示

```
    0 a > 2 > 3^
    1 b > 0 > 2 > 5^ 
    2 c > 1 > 4^
    3 d > 4^
    4 e > 6^
    5 f > b^
    6 g^
```

### 边集数组
* 带权图的一种存储结构是边集数组，适用于一些以边为主的操作。数组中每个元素代表一条边信息，结构如下：
    * beginvertex：一条边的起始顶点
    * endvertex： 一条边的结束顶点
    * weight：边上的权

|beginvertex |endvertex |weight|
|--|--|--|
|0|1|6|
|0|2|5|
|1|5|5|
|1|3|3|
|2|5|5|
|2|4|2|
|3|5|6|
|3|4|6|
|4|5|4|

# 2 图的python实现

## 2.1 邻接矩阵实现

```
class Graph:
    def __init__(self, mat, unconn=0):
        vnum = len(mat)
        for x in mat:
            if len(x) != vnum:
                raise ValueError('Argument for graph')
        self.mat = [i[:] for i in mat]
        
        self.unconn = unconn
        self.vnum = vnum
        
    def _invalid(self, v):
        return 0 > v or v >= self.vnum
    
    def is_empty(self):
        return not self.mat
        
    def vertex_num(self):
        return self.vnum
        
    def edge_num(self):
        return len([x for x in v for v in self.mat if x != self.unconn])
        
    def add_vertex(self, vertex):
        if len(vertex) != self.vnum+1:
            raise ValueError('argument for add_vertex')
        for i in range(self.vnum):
            self.mat[i].append(vertex[i])
        self.mat.append(vertex)
        self.vnum += 1
          
    def add_edge(self, vi, vj, val=1):
        if self._invalid(vi) or self._invalid(vj):
            raise ValueError('argument for add_edge')
        self.mat[vi][vj] = val
        
    def get_edge(self, vi, vj):
        if self._invalid(vi) or self._invalid(vj):
            raise ValueError('argument for get_edge')
        return self.mat[vi][vj]
        
    def out_edge(self, v):
        if self._invalid(v):
            raise ValueError('argument for out_edge')
        return self._out_edge(self.mat[v], self.unconn)
        
    def degrees(self, v):
        if self._invalid(v):
            raise ValueError('argument for degrees')
        return len([x for x in self.mat[v] if x != self.unconn])
    
    @staticmethod
    def _out_edge(row, unconn):
        edges = []
        for i in range(len(row)):
            if row[i] != unconn:
                edges.append((i, row[i]))
        return edges
        
    def __str__(self):
        return "\n" + ",\n".join(map(str, self.mat)) + "\n" \
        + "\n UnConnect:" + str(self.unconn)
    
```

## 2.2 邻接表实现
* 邻接表中邻接数据使用元组实现(v, wight)
* GraphAL继承Graph类，提供同样的接口。内部实现完全不同，少数方法可以继承，甚至完全不继承。不继承徐拷贝几个重用的方法，因此继承还是有益的。

```
class GraphAL(Graph):
    def __init__(self, mat, unconn=0):
        vnum = len(mat)
        for x in mat:
            if len(x) != vnum:
                raise ValueError("argument for GraphAL")
        self.mat = [Graph._out_edge(i, unconn) for i in mat]
        self.vnum = vnum
        self.unconn = unconn
        
    def edge_num(self):
        return sum([len(v) for v in self.mat])
        
    def add_vertex(self, vertex):
        self.mat.append([])
        self.vnum += 1
        return self.vnum - 1
          
    def add_edge(self, vi, vj, val=1):
        if self.vnum <= 0:
            raise ValueError('cannot add edge to empty graph')
        if self._invalid(vi) or self._invalid(vj):
            raise ValueError('argument for add_edge')
        row = self.mat[vi]
        is_contains = False
        for i in range(len(row)):
            if row[i][0] == vj:
                row[i] = (vj, val)
                is_contains = True
                break
        if not is_contains:
            row.append((vj, val))               
           
    def get_edge(self, vi, vj):
        if self._invalid(vi) or self._invalid(vj):
            raise ValueError('argument for get_edge')
        row = self.mat[vi]
        for i, val in row:
            if i == vj:
                return val
        return self.unconn
                
    def out_edge(self, v):
        if self._invalid(v):
            raise ValueError('argument for out_edge')
        return self.mat[v]
        
    def degrees(self, v):
        if self._invalid(v):
            raise ValueError('argument for degrees')
        return len(self.mat[v])
    
```

## 2.3 小结
* 上面两类实现了相同的接口，提供了同样的api
* 两种实现的操作效率不同
* 上面两个类主要提供了边信息，顶点只是一个编号。实际中顶点还有更多信息，可以考虑再图对象中加入一个顶点表或者顶点字典。

# 3. 图的基本算法
图的算法复杂度很重要，因为低效的算法无法处理一定规模的问题。这些算法中会用到一些数据结构，特别是栈、队列和优先队列。

## 3.1 图的遍历
按照某种方式系统的访问图中的每个顶点且仅访问一次。

* 基于数据结构遍历：如邻接矩阵或邻接表的图，通过下标访问图中的各个顶点。
* 基于邻接关系的遍历：如基于一个顶点遍历所有可达的顶点或达到某个顶点。图不一定是连通的，因此还要考虑对未能遍历的其他部分处理。

基于一般状态空间搜索的方式完成图的遍历。基本方法就是深度优先遍历和广度优先遍历。

到达同一个顶点的路径不止一条，而且可能存在回路。用标记顶点技术解决这个问题。

### 3.1.1 深度优先遍历（Depth-First Search）
从顶点v出发，步骤：
* 访问顶点v并将它标记为已访问。
* 检查v的邻接顶点，选择一个尚未访问的顶点，从它出发进行深度优先搜索（递归）。不存在这种邻接顶点时回溯。
* 反复上述操作知道从v出发的所有顶点都已经访问（递归）。
* 如果图中还有未访问的顶点，选出一个未访问的顶点，由它出发重复前述过程，直到图中所有顶点都已访问为止。

通过深度优先搜索得到的序列称为深度优先搜索序列，简称DFS序列。如果图中顶点顺序不确定则DFS序列不唯一。


### 3.1.2 广度优先遍历（Breadth-First Search）
从顶点vi出发，步骤如下：
* 访问顶点vi并将其标记为已访问。
* 依次访问vi的所有邻接点vi0, vi1,..., vim-1(可能规定某种顺序)。再依次访问与vi0, vi1,...,vim-1邻接的所有尚未访问的顶点，直到所有可达的顶点都已访问。
* 如果图中还存在未访问的顶点，选择一个未访问的顶点，由它出发重复前述过程，直到图中所有的顶点由已访问。

通过广度优先搜索得到的序列称为广度优先搜索序列，简称BFS序列。如果图中顶点顺序不确定则BFS序列不唯一。