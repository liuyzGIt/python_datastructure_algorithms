# 1. 检索

数据检索牵涉两个方面：
1. 已存储的数据集合
2. 用户检索时提供的检索信息。

检索结果分两种：
1. 确定特定的数据是否存储在数据集中，相当于集合成员判断。
2. 找到与检索提供的信息相关的数据，类似于查字典。检索时提供的数据称为**检索码**或**关键码**。关键码常作为数据的一部分，存储在数据集合中。

**本章讨论的主题是基于关键码和数据存储的检索。**

关键码通常是数据项的某种（可能具有唯一性）的特征。可以是数据内容的一部分，也可以是专门为检索建立的标签。

下面我们讨论的数据元素由两部分构成：一部分是关键码，另一部分是与关键码关联的数据。

数据存储和访问是计算机中的基本操作，对系统的整体效率影响很大。

支持数据量大、经常变动、高校检索的数据集合，需要其他的数据结构：
1. 基于散列(hash)思想的散列表。
2. 基于各种树形结构的存储和检索技术。

# 2 字典的线性表实现

字典也被称为查找表，映射或者关联表。

字典由多种实现方式，如顺序表、二叉树或其他组合。

字典课分为两类：
* 静态字典：建立后，字典的结构和内容不再变化，主要操作是检索。
* 动态字典：字典的内容(和结构)都在变化中。主要操作是检索、插入、修改、删除。

评价字典效率的标准是平均检索长度(Average Search Length)，即一次完整的检索中比较关键码的平局次数。`ASL=∑pi*ci(i∈[0,n-1])`。n为字典中数据项的个数；ci是第i项的检索长度；pi是第i项的检索概率。如果字典中各项检索的概率相等，则`pi=1/n`，那么`ASL=1/n∑ci`。

## 2.1 索引
字典除了村塾数据外，还有一种功能就是索引。

索引就是根据关键码找到其关联信息，也就是实现关键码到关联信息的映射。

## 2.2 字典的实现问题

### 2.2.1 抽象数据类型
* ADT Dict
    * Dict() 初始化
    * is_empty() 
    * num() 字典的元素个数
    * search(key)  检索key关联的数据
    * insert(key, value) 字典中加入元素
    * delete(key) 字典中删除元素
    * keys() 迭代的方式获取所有key
    * values() 迭代的方式获取所有value
    * entries() 迭代的方式获取key/value的二元组


### 2.2.2 字典元素：关联
字典的关键码和值这样一个数据项，是一个二元组，我们这里称为关联。

下面定义了关联的操作，如果需要可以定义其他运算。
```
class Assoc:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        
    def __lt__(self, other):
        return self.key < other.key
        
    def __le__(self, other):
        return self.key < other.key or self.key == other.key
        
    def __str__(self):
        return "Assoc({0}, {1})".format(self.key, self.value)
```

## 2.3 字典的线性表实现

### 2.3.1 简单线性表实现
一般字典如果插入时遇到相同的关键码，就简单修改其关联值。删除时如果没有找到关键码，则什么也不操作。


字典用list实现，关联用tuple或者list实现。

实现方式的特点：
* 数据结构和算法简单。顺序处理数据。
* 平均检索效率低(O(n)),当n很大时，检索很耗时
* 删除操作的效率比较低，不适合频繁变动的字典。


### 2.3.2 改进：排序的线性表
要提高操作效率，需要把数据组织好，使其有可利用的结构。

比如key取自一个有序集合（数字或者字母等）按照字典的关键码进行排序，采用二分查找法快速检索。

二分查找法：
1. 初始时，考虑的元素区间是整个字典(一个顺序表)。
2. 取所考虑的元素范围内剧中的数据项，该项与关键码比较，如果相等则表结束。
3. 如果检索码大，则把检索范围修改为中间区间之后的版区间；如果检索码小，则把检索范围修改为中间区间之前的半区间。
4. 如果再关注范围内仍有数据，就回到步骤2继续。否则检索失败并结束。

顺序表和二分检索：
* 主要优点是检索速度快，O(logn).
* 插入和删除都要维护数据项顺序，O(n)操作（检索插入/删除位置可以用二分查找）。
* 二分法技术只适用于关键码可排序、数据项按关键码排序的字典，只适用于顺序存储结构，需要连续空间，不适合较大的动态字典。

```
# 二分查找
def binsearch(lst, key):
    low, high = 0, len(lst)-1
    while low <= high:
        mid = low + (high - low) // 2
        if key == lst[mid].key:
            return lst[mid].value
        elif key < lst[mid].key:
            high = mid -1
        else:
            low = mid + 1

```

## 2.4 字典线性表总结
基于单链表或双链表实现，简单分析如下：
* 如果数据项任意排序，插入简单再表头插入，是O(1)操作；检索和删除需要扫描整个表，O(n)操作。
* 如果表中的数据按照关键码升序或降序排列，插入需要检索正确位置，是O(n)操作。检索和删除童谣需要扫描检查，平均查找半个表，是O(n)操作。

使用链表没有明显优势。

采用排序表和二分查找的问题：
* 不能很好的支持数据变化。
* 必须采用连续的存储空间储存。


# 3. 散列和散列表
